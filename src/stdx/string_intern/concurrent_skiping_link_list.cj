/*
 *  Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 *  This source file is part of the Cangjie project, licensed under Apache-2.0
 *  with Runtime Library Exception.
 *
 *  See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.string_intern

import std.collection.LinkedList
import std.collection.HashMap
import std.collection.Map
import std.sync.Mutex

/**
 * Skipping table is a data structure based on a multi-layer linked list that provides fast search, insert, and delete operations.
 * Jumping tables accelerate the process of searching for nodes by maintaining multi-level indexes, thus improving the efficiency of deletion operations to a certain extent.
 * The differences between this linked list and the linked list in the standard library are as follows:
 * 1. The synchronous access method is implemented.
 * 2. The hashmap is used to store the relationship between values and nodes, and the value-based deletion method is provided.
 * 3. To use a skip table, ensure that the data elements in the linked list are different or unique.
 */
internal class ConcurrentSkipingLinkList<T> <: ILinkList<T> where T <: Hashable & Equatable<T> {
    protected var valueList: LinkedList<T> = LinkedList<T>()
    protected var valueMap: Map<T, LinkedListNode<T>> = HashMap<T, LinkedListNode<T>>()
    let mtx = Mutex()

    public func clear(): Unit {
        synchronized(mtx) {
            valueList.clear()
            valueMap.clear()
        }
    }

    public func getSize(): Int64 {
        return valueList.size
    }

    public func remove(input: T): Bool {
        synchronized(mtx) {
            let nodeOP: Option<LinkedListNode<T>> = valueMap.remove(input)
            if (let Some(node) <- nodeOP) {
                valueList.remove(node)
                return true
            } else {
                return false
            }
        }
    }

    public func popLast(): Option<T> {
        synchronized(mtx) {
            let valueOP: Option<T> = valueList.removeLast()
            if (let Some(key) <- valueOP) {
                valueMap.remove(key)
            }
            return valueOP
        }
    }

    public func popFirst(): Option<T> {
        synchronized(mtx) {
            let valueOP: Option<T> = valueList.removeFirst()
            if (let Some(key) <- valueOP) {
                valueMap.remove(key)
            }
            return valueOP
        }
    }

    public func firstNode(): Option<LinkedListNode<T>> {
        return valueList.firstNode
    }

    public func lastNode(): Option<LinkedListNode<T>> {
        return valueList.lastNode
    }

    public func prepend(element: T): LinkedListNode<T> {
        synchronized(mtx) {
            let newNode: LinkedListNode<T> = valueList.addFirst(element)
            valueMap.add(element, newNode)
            return newNode
        }
    }

    public func append(element: T): LinkedListNode<T> {
        synchronized(mtx) {
            let newNode: LinkedListNode<T> = valueList.addLast(element)
            valueMap.add(element, newNode)
            return newNode
        }
    }

    public func getNextNode(element: T): ?LinkedListNode<T> {
        var item = valueMap.get(element)
        if (let Some(node) <- item) {
            return node.next
        }
        return None
    }

    public func appendBefore(element: T, oldkey: ?T): LinkedListNode<T> {
        if (oldkey.isNone()) {
            return append(element)
        }
        var oldNode = valueMap.get(oldkey.getOrThrow())
        if (let Some(node) <- oldNode) {
            var newNode = valueList.addBefore(node, element)
            valueMap.add(element, newNode)
            return newNode
        } else {
            return append(element)
        }
    }

    public func makeFirst(element: T): Bool {
        synchronized(mtx) {
            if (valueMap.contains(element)) {
                this.remove(element)
                this.prepend(element)
                return true
            } else {
                this.prepend(element)
                return false
            }
        }
    }
    public func makeLast(element: T): Bool {
        synchronized(mtx) {
            if (valueMap.contains(element)) {
                this.remove(element)
                this.append(element)
                return true
            } else {
                this.append(element)
                return false
            }
        }
    }
}
