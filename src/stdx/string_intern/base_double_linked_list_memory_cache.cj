/*
 *  Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 *  This source file is part of the Cangjie project, licensed under Apache-2.0
 *  with Runtime Library Exception.
 *
 *  See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.string_intern

/**
 * @brief  Base class for storing cached keys using bidirectional linked lists.
 * Cache algorithms such as LRU and FIFO can be quickly implemented by inserting headers and tails of linked lists.
 * The following two abstract methods of the definition class need to be implemented by subclasses.
 *
 * adjustCacheAfterHit：This key is used to implement processing after a cache hit.
 *     For example, in the LRU algorithm, if a cache hit occurs, the key needs to be placed in the header of the queue, indicating that the cache has been recently accessed.
 * adjustCacheAfterPut：Used for post-cache processing.
 *     For example, in the LRU, the newly added cache value needs to be added to the header of the key queue.
 */
internal abstract class BaseDoubleLinkedListMemoryCache<K, V> <: BaseMemoryCache<K, V> where K <: Hashable & Equatable<K> {
    protected var cacheKeyLinkList: ILinkList<K> = ConcurrentSkipingLinkList<K>()

    public init(cacheConfigs!: ?ICacheConfig, cacheKeyLinkList!: ILinkList<K> = ConcurrentSkipingLinkList<K>()) {
        super(cacheConfigs: cacheConfigs)
        this.cacheKeyLinkList = cacheKeyLinkList
    }

    /**
     * Cache hit post-processing, which is implemented by subclasses
     *
     * @param cacheObj Current hit cache
     */
    protected func adjustCacheAfterHit(cacheObj: ICacheObj<K, V>): Unit

    /**
     * Performs post-update processing, which is implemented by subclasses
     *
     * @param cacheObj Current hit cache
     */
    protected func adjustCacheAfterPut(cacheObj: ICacheObj<K, V>, oldObj!: ?ICacheObj<K, V>): Unit

    /**
     * Reset the cache and clear data
     */
    public func initializeCache(): Unit {
        cacheKeyLinkList.clear()
    }

    /**
     * Release all occupied space in the cache
     */
    public func removeAll(): Unit {
        synchronized(super.lock) {
            super.removeAll()
            cacheKeyLinkList.clear()
        }
    }

    /**
     * Release a specified number of caches: For example, in the LRU cache, the specified number of least used elements are released.
     *
     *  @param numberToReleasee Number of cached elements released
     *  @return Number of cached elements that are actually released. If 10 elements are requested to be released but there are only three elements in the cache, the value 3 is returned.
     */
    public func release(numberToRelease: Int64): Int64 {
        var freedNum: Int64 = 0
        synchronized(super.lock) {
            for (_ in 0..numberToRelease) {
                let cacheObjOP = cacheKeyLinkList.popLast()
                if (let Some(cache) <- cacheObjOP) {
                    remove(cache)
                    freedNum++
                }
            }
        }
        return freedNum
    }

    /**
     * Puts a cache object into the cache..
     * <p>
     * @param cobj Cache object
     */
    public open func put(cobj: ICacheObj<K, V>): Unit {
        synchronized(super.lock) {
            let oldOp: Option<ICacheObj<K, V>> = super.cacheItemMap.add(cobj.key, cobj)
            if (let Some(old) <- oldOp) {
                cacheKeyLinkList.remove(old.key)
            }
            adjustCacheAfterPut(cobj, oldObj: oldOp)
        }

        spoolIfNeeded()
    }

    protected open func report(_: ICacheObj<K, V>, _: String) {
    }

    private func spoolIfNeeded() {
        let size = getSize()
        if (size > this.cacheConfigs.getOrThrow().maxObjects) {
            let chunkSize: Int64 = min(size, this.cacheConfigs.getOrThrow().spoolChunkSize)
            synchronized(super.lock) {
                release(chunkSize)
            }
        }
    }

    /**
     * Removes an element object whose key is key from the cache.
     * <p>
     * @param key Cache key value
     * @return Whether the element object corresponding to the cache exists
     */
    public open func remove(inputKey: K): Bool {
        synchronized(super.lock) {
            cacheKeyLinkList.remove(inputKey)
            return super.remove(inputKey)
        }
    }
}
