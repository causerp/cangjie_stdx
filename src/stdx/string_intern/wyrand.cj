/*
 *  Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 *  This source file is part of the Cangjie project, licensed under Apache-2.0
 *  with Runtime Library Exception.
 *
 *  See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.string_intern

/**
 * @brief cangjie version of wyRand & wyHash
 *
 * wyRand is a fast pseudo-random function, It can eliminate the performance loss caused by bad hashes.
 *
 * @param seed The seed to generate a 64-bit random number
 */
const secret0 = 0xa0761d6478bd642fu64
const secret1 = 0xe7037ed1a0b428dbu64
const secret2 = 0x8ebc6af09c88c6e3u64
const secret3 = 0x589965cc75374cc3u64

@OverflowWrapping
func wyrand(seed: Int64) {
    let v: UInt64 = UInt64(seed) + secret0
    return Int64(mix(v, v ^ secret1))
}

@OverflowWrapping
func wyhash(arr: Array<UInt8>, start: Int64, size: Int64, seed: UInt64): UInt64 {
    var _seed = seed ^ mix(seed ^ secret0, secret1)
    if (size == 0) {
        return _seed
    }
    var a: UInt64
    var b: UInt64
    match {
        case size < 4 =>
        a = (UInt64((arr[start])) << 16) | (UInt64((arr[start + (size >> 1)])) << 8) | (UInt64((arr[start + size - 1])))
        b = 0
        case size == 4 =>
        a = r4(arr, start)
        b = a
        case size < 8 =>
        a = r4(arr, start)
        b = r4(arr, start + size - 4)
        case size <= 16 =>
        a = r8(arr, start)
        b = r8(arr, start + size - 8)
        case _ =>
        var pos = start
        var l = size
        if (l > 48) {
            var seed1 = _seed
            var seed2 = _seed

            do {
                _seed = mix(r8(arr, pos) ^ secret1, r8(arr, pos + 8) ^ _seed)
                seed1 = mix(r8(arr, pos + 16) ^ secret2, r8(arr, pos + 24) ^ seed1)
                seed2 = mix(r8(arr, pos + 32) ^ secret3, r8(arr, pos + 40) ^ seed2)
                pos += 48
                l -= 48
            } while (l > 48)
            _seed = _seed ^ seed1 ^ seed2
        }

        while (l > 16) {
            _seed = mix(r8(arr, pos) ^ secret1, r8(arr, pos + 8) ^ _seed)
            l -= 16
            pos += 16
        }
        a = r8(arr, pos + l - 16)
        b = r8(arr, pos + l - 8)
    }
    a ^= secret1
    b ^= _seed
    return mix(a ^ secret0 ^ UInt64(size), b ^ secret1)
}

@OverflowWrapping
func mix(A: UInt64, B: UInt64): UInt64 {
    let ha: UInt64 = A >> 32
    let hb: UInt64 = B >> 32
    let la: UInt64 = UInt64(UInt32(A))
    let lb: UInt64 = UInt64(UInt32(B))
    let rh = ha * hb
    let rm0 = ha * lb
    let rm1 = hb * la
    let rl = la * lb
    let t = rl + (rm0 << 32)
    var c: UInt64 = if (t < rl) {
        1
    } else {
        0
    }
    let lo = t + (rm1 << 32)
    c += if (lo < t) {
        1
    } else {
        0
    }
    let hi = rh + (rm0 >> 32) + (rm1 >> 32) + c
    return lo ^ hi
}

@OverflowWrapping
func r4(arr: Array<UInt8>, pos: Int64): UInt64 {
    (UInt64((arr[pos])) << 24) | (UInt64((arr[pos + 1])) << 16) | (UInt64((arr[pos + 2])) << 8) | UInt64((arr[pos + 3]))
}

@OverflowWrapping
func r8(arr: Array<UInt8>, pos: Int64): UInt64 {
    (UInt64((arr[pos])) << 56) | (UInt64((arr[pos + 1])) << 48) | (UInt64((arr[pos + 2])) << 40) | (UInt64((arr[pos + 3])) <<
            32) | (UInt64((arr[pos + 4])) << 24) | (UInt64((arr[pos + 5])) << 16) | (UInt64((arr[pos + 6])) << 8) | UInt64((arr[pos +
            7]))
}
